//
// Created by Enno Adler on 14.11.24.
//

#include "cutter.h"

// The idea is, that there is a rule for each terminal C that has C as its left child to indicate terminals.
#define is_terminal(D, C) (D->rule[C].left == C)
// D->rule[C].right == DUMMY_CODE is not needed, as the above criteria is enough.

/**
 * Computes the length of the string generated by the rule of code c.
 * TODO: Could be saved in the grammar already, which would save much time.
 */
uint get_generated_length(DICT *d, CODE c);

uint get_generated_length(DICT *d, CODE c) {
    CODE left, right;

    left  = d->rule[c].left;
    right = d->rule[c].right;
    if (is_terminal(d, c)) {
        return 1;
    }
    else
    {
        return get_generated_length(d, left) + get_generated_length(d, right);
    }
}

void copy_start(DICT *d, CODE c, uint relative_from_position, DICT *ret, uint *next_char_position) {
    // We assume 1 <= relative_from_position < get_generated_length(d, c), so it is not a boundary of our generating interval.
    CODE left, right;
    left  = d->rule[c].left;
    right = d->rule[c].right;

    uint gen_len_left = get_generated_length(d, left);
    if (relative_from_position < gen_len_left)
    {
        // Towards the left symbol
        copy_start(d, left, relative_from_position, ret, next_char_position);
        ret->comp_seq[(*next_char_position)++] = right;
    }
    else
    if (relative_from_position == gen_len_left)
    {
        // Case that we have exactly the left boundary of the right symbol aka the right boundary of the left symbol.
        ret->comp_seq[(*next_char_position)++] = right;
    }
    else
    {
        // Towards the right symbol
        copy_start(d, right, relative_from_position - gen_len_left, ret, next_char_position);
    }
}

void copy_end(DICT *d, CODE c, uint relative_to_position, DICT *ret, uint *next_char_position) {
    // We assume 1 <= relative_from_position < get_generated_length(d, c)
    CODE left, right;
    left  = d->rule[c].left;
    right = d->rule[c].right;

    uint gen_len_left = get_generated_length(d, d->rule[c].left);
    if (relative_to_position < gen_len_left)
    {
        // Towards the left symbol
        copy_end(d, left, relative_to_position, ret, next_char_position);
    }
    else
    if (relative_to_position == gen_len_left)
    {
        // Case that we have exactly the left boundary of the right symbol aka the right boundary of the left symbol.
        ret->comp_seq[(*next_char_position)++] = left;
    }
    else
    {
        // Towards the right symbol
        ret->comp_seq[(*next_char_position)++] = left;
        copy_end(d, right, relative_to_position - gen_len_left, ret, next_char_position);
    }
}

DICT *get_excerpt_from_grammar(DICT *d, uint from, uint to)
{
    // Check for valid query
    if (from >= d->txt_len) {
        return createDict(0);
    }

    // STEP 1: Find bounds in start-rule.
    uint chars_generated_until_position = 0; // Counts the numbers of chars visited in the uncompressed string of the grammar.
    uint startrule_position_from = 0; // position withing d->seq of the first symbol in the interval.
    uint startrule_position_to;
    uint next_symbol_generated_length;
    uint relative_from_position;
    uint relative_to_position;

    while (startrule_position_from < d->seq_len && chars_generated_until_position + (next_symbol_generated_length = get_generated_length(d, d->comp_seq[startrule_position_from])) < from)
    {
        chars_generated_until_position += next_symbol_generated_length;
        startrule_position_from++;
    }
    relative_from_position = from - chars_generated_until_position;

    startrule_position_to = startrule_position_from;
    while (startrule_position_to < d->seq_len && chars_generated_until_position + (next_symbol_generated_length = get_generated_length(d, d->comp_seq[startrule_position_to])) < to)
    {
        chars_generated_until_position += next_symbol_generated_length;
        startrule_position_to++;
    }
    relative_to_position = to - chars_generated_until_position;

    // STEP 2: Copy Start Rule and resolve edge cases. TODO: Count vocc(A) while copying.
    DICT *ret = createDict(to - from); // Worst Case text length is the full interval.
    ret->comp_seq = malloc( (to - from) * sizeof (CODE));
    if (ret->comp_seq == NULL)
        goto err1;
    uint next_char_position = 0;
    uint chars_to_copy;
    if (relative_from_position != 0)
    {
        chars_to_copy = (startrule_position_to - startrule_position_from - 1);
        copy_start(d, d->comp_seq[startrule_position_from], relative_from_position, ret, &next_char_position);
        startrule_position_from++;
    }
    else
    {
        chars_to_copy = (startrule_position_to - startrule_position_from);
    }
    memcpy(&(ret->comp_seq[next_char_position]), &(d->comp_seq[startrule_position_from]), chars_to_copy * sizeof(CODE));
    next_char_position += chars_to_copy; // Move the pointer of the next symbol.

    if (relative_to_position != 0)
    {
        copy_end(d, d->comp_seq[startrule_position_to], relative_to_position, ret, &next_char_position);
    }

    CODE *p = realloc(ret->comp_seq, next_char_position * sizeof(CODE)); // Free unnecessary space.
    if (p == NULL)
    {
        goto err1; // This should not happen, because it needs less memory.
    }
    ret->comp_seq = p;
    ret->seq_len = next_char_position;

    // STEP 3: Copy grammar rules used. TODO: Normalize grammar rule names? Is this a necessary step?
    ret->rule = d->rule;
    ret->num_rules = d->num_rules;
    // STEP 4: Recompress

    recompress(ret, 3);

    return ret;

err1:
    free(ret);
    return NULL;
}